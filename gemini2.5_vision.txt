import os
import json
import google.generativeai as genai
from pdf2image import convert_from_path
from PIL import Image
from typing import Dict, Any, List

# ==========================================
# [ì„¤ì •]
# ==========================================
MY_API_KEY = "AIzaSyBRQJ1uVE5UVvB6jO6HvRhB5LTfWncsqN8"  # ë³¸ì¸ì˜ API í‚¤
MODEL_NAME = "gemini-2.5-flash"
genai.configure(api_key=MY_API_KEY, transport="rest")

# â˜… ì¤‘ìš”: ì•„ê¹Œ ë‹¤ìš´ë°›ì€ Popplerì˜ bin í´ë” ê²½ë¡œë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš” ( \ ëŒ€ì‹  / ì‚¬ìš© ê¶Œì¥ )
# ì˜ˆì‹œ: r"C:\Start\poppler-24.02.0\Library\bin"
POPPLER_BIN_PATH = r"C:\poppler\Library\bin"

class TravelVisionAI:
    def __init__(self):
        self.model = genai.GenerativeModel(MODEL_NAME)
        # Target Schema
        self.target_schema = {
            "basic_info": {"product_type": None, "is_flight_included": None, "is_vat_included": None},
            "location_info": {"country": None, "city": None, "departure_port": None},
            "product_info": {
                "product_name": None,
                "event_period": {"available_days": []}
            },
            "hotels": [{"name_kr": None, "description": None, "meta_info": {"check_in_out": None, "website": None}}],
            "golf_courses": [{"name_kr": None, "operation_info": None, "meta_info": {"detail_info": None, "website": None}}],
            "tourist_spots": [{"name": None}],
            "details": {
                "inclusions": [], "exclusions": [], "others": None,
                "is_insurance_included": None, "is_guide_included": None,
                "special_notes": []
            },
            "ai_content": {"body_text": None},
            "flight_info": {"airline": None, "flight_number": None, "departure_time": None, "arrival_time": None},
            "price_info": [] 
        }

    def _pdf_to_images(self, pdf_path):
        print(f"   -> ë³€í™˜ ì¤‘: {os.path.basename(pdf_path)}")
        try:
            # [ìˆ˜ì •] dpië¥¼ 400ìœ¼ë¡œ ë†’ì—¬ì„œ ì‘ì€ ìˆ«ìë„ ì„ ëª…í•˜ê²Œ ì¸ì‹í•˜ë„ë¡ í•¨
            return convert_from_path(pdf_path, dpi=400, poppler_path=POPPLER_BIN_PATH)
        except Exception as e:
            print(f"âŒ Poppler ì—ëŸ¬: {e}")
            return []

    def process(self, product_pdf: str, price_pdf: str = None):
        print(">>> [1/3] ë¬¸ì„œ ì´ë¯¸ì§€ ë³€í™˜ ì¤‘...")
        prod_images = self._pdf_to_images(product_pdf)
        price_images = self._pdf_to_images(price_pdf) if price_pdf else []
        
        if not prod_images:
            return {"error": "ìƒí’ˆ PDF ë³€í™˜ ì‹¤íŒ¨"}

        print(">>> [2/3] Gemini Vision ë¶„ì„ ì¤‘...")
        
        # ìƒí’ˆ ì •ë³´ ì¶”ì¶œ
        product_json = self._extract_product_info(prod_images)
        
        # ê°€ê²© ì •ë³´ ì¶”ì¶œ
        target_images = price_images if price_images else prod_images
        price_json = self._extract_price_info(target_images)
        
        print(">>> [3/3] ë°ì´í„° ë³‘í•© ì¤‘...")
        final_data = self._merge(product_json, price_json)
        return final_data

    def _extract_product_info(self, images):
        # [ìˆ˜ì •] product_type ë¶„ë¥˜ ë¡œì§ ì¶”ê°€ (Prompt + Python Logic)
        prompt = f"""
        Role: Travel Product Analyst.
        Task: Analyze the images and extract product details into JSON.
        
        [CRITICAL LANGUAGE RULES]
        1. **OUTPUT VALUES MUST BE IN KOREAN.** (e.g., "Japan"->"ì¼ë³¸")
        2. **DO NOT TRANSLATE KEYS.**
        
        [Extraction Focus]
        1. **Location**: Identify the `country` and `city` accurately.
           - If `country` is South Korea, map as "í•œêµ­".
        2. **Product Type Logic**:
           - If `country` is "í•œêµ­" (or Jeju), set `product_type` to "êµ­ë‚´ìƒí’ˆ".
           - Otherwise, set `product_type` to "í•´ì™¸ìƒí’ˆ".
        3. **Flight Info**: Look specifically for flight codes (LJ, KE, TW, etc.) and times.
        4. Flight Status: Set is_flight_included to "í¬í•¨" if flight codes are present, otherwise "ë¶ˆí¬í•¨".
        
        [Target JSON Schema]
        {json.dumps(self.target_schema, ensure_ascii=False)}
        """
        try:
            content = [prompt] + images
            res = self.model.generate_content(
                content,
                generation_config={"response_mime_type": "application/json"},
                request_options={"timeout": 120}
            )
            data = json.loads(res.text)
            
            # 1. ë¦¬ìŠ¤íŠ¸ë¡œ ë°˜í™˜ë  ê²½ìš° ì²« ë²ˆì§¸ ìš”ì†Œ ì¶”ì¶œ
            if isinstance(data, list):
                data = data[0] if len(data) > 0 else {}

            # ==========================================================
            # [Python í›„ì²˜ë¦¬] product_type ê°•ì œ ë³´ì • ë¡œì§
            # AIê°€ í—·ê°ˆë ¤ë„ ì—¬ê¸°ì„œ í™•ì‹¤í•˜ê²Œ ì¡ì•„ì¤ë‹ˆë‹¤.
            # ==========================================================
            country = data.get("location_info", {}).get("country", "")
            if country:
                # í•œêµ­ ê´€ë ¨ í‚¤ì›Œë“œê°€ ìˆìœ¼ë©´ êµ­ë‚´ìƒí’ˆ
                if any(x in country for x in ["í•œêµ­", "ëŒ€í•œë¯¼êµ­", "ì œì£¼", "Korea"]):
                    data["basic_info"]["product_type"] = "êµ­ë‚´ìƒí’ˆ"
                    # í˜¹ì‹œ êµ­ê°€ëª…ì´ 'Korea'ë¡œ ë˜ì–´ìˆìœ¼ë©´ 'í•œêµ­'ìœ¼ë¡œ í†µì¼
                    data["location_info"]["country"] = "í•œêµ­"
                else:
                    # ê·¸ ì™¸ì—ëŠ” ëª¨ë‘ í•´ì™¸ìƒí’ˆ
                    data["basic_info"]["product_type"] = "í•´ì™¸ìƒí’ˆ"
            
            return data
            
        except Exception as e:
            print(f"Product Extract Error: {e}")
            return {}
            
    def _extract_price_info(self, images):
        all_prices = []
        seen_entries = set() # ì¤‘ë³µ ë°ì´í„° ë°©ì§€ìš© í‚¤ ì €ì¥ì†Œ

        print(f"   -> ì´ {len(images)}ì¥ì˜ ê°€ê²©í‘œ ì´ë¯¸ì§€ë¥¼ ë¶„ì„í•©ë‹ˆë‹¤ (ìŠ¤ë§ˆíŠ¸ ë ˆì´ì•„ì›ƒ ì ìš©).")

        for page_idx, full_img in enumerate(images):
            width, height = full_img.size
            
            # [ì „ëµ ë³€ê²½] ê°€ë¡œ(ì¢Œìš°)ëŠ” ìë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤! (ê¸€ì ì˜ë¦¼ ë°©ì§€)
            # ëŒ€ì‹  ì„¸ë¡œ(ìƒí•˜)ë§Œ ê²¹ì¹˜ê²Œ ì˜ë¼ì„œ í•´ìƒë„ë¥¼ í™•ë³´í•©ë‹ˆë‹¤.
            # ë°ì´í„°ê°€ ì ìœ¼ë©´ êµ³ì´ ìë¥´ì§€ ì•Šì•„ë„ ë˜ì§€ë§Œ, 1ë…„ì¹˜ ë°ì´í„°ëŠ” ê¸¸ê¸° ë•Œë¬¸ì— ìƒí•˜ ë¶„í•  ì¶”ì²œ.
            
            # ìƒí•˜ ë¶„í•  (ì¤‘ê°„ 20% ì¤‘ì²©)
            split_point_1 = int(height * 0.6)
            split_point_2 = int(height * 0.4)
            
            # ë§Œì•½ ì´ë¯¸ì§€ê°€ ë„ˆë¬´ ì‘ìœ¼ë©´(ë†’ì´ 1000px ì´í•˜) êµ³ì´ ìë¥´ì§€ ì•ŠìŒ
            if height < 1000:
                chunks = [(full_img, f"Page {page_idx+1} (Full)")]
            else:
                chunks = [
                    (full_img.crop((0, 0, width, split_point_1)), f"Page {page_idx+1} (Top Section)"),
                    (full_img.crop((0, split_point_2, width, height)), f"Page {page_idx+1} (Bottom Section)")
                ]
            
            print(f"      Running Page {page_idx + 1}...")

            for chunk_idx, (img_chunk, position) in enumerate(chunks):
                
                # [í•µì‹¬ í”„ë¡¬í”„íŠ¸] ë‹¤ë‹¨(Multi-Column) ë ˆì´ì•„ì›ƒ ì¸ì‹ ì§€ì‹œ
                prompt = f"""
                Role: Travel Price Analyst.
                Task: Extract **ALL** pricing data from the image into CSV format.
                
                [CRITICAL LAYOUT INSTRUCTION]
                1. **Multi-Column Detection**: The image may contain **multiple tables arranged side-by-side** (e.g., 2 or 3 columns of tables).
                2. **Scan Order**: Read the tables from **Left -> Right**, and within each table, read **Top -> Bottom**.
                3. **Do Not Miss**: You must extract data from ALL columns/tables visible in the image.

                [Output Format]
                1. **Format**: CSV only (No JSON, No Markdown).
                2. **Columns**: `departure_date, night_count, day_count, group_size, price_adult`
                3. **Separator**: Comma (`,`)

                [Data Rules]
                1. **departure_date**: YYYY-MM-DD. (Treat Red/Black text equally).
                2. **night/day**: Integer only.
                3. **group_size**: Integer. If header says "4ì¸", apply to all rows below.
                4. **price_adult**: Integer (remove commas).
                """
                
                try:
                    res = self.model.generate_content(
                        [prompt, img_chunk],
                        generation_config={
                            "max_output_tokens": 8192,
                            "temperature": 0.0 # ì •í™•ë„ ìµœìš°ì„ 
                        },
                        request_options={"timeout": 120}
                    )
                    
                    csv_text = res.text.strip()
                    
                    # íŒŒì‹± ë¡œì§ (ì¤‘ë³µ ì œê±° í¬í•¨)
                    new_rows = self._parse_csv_to_json(csv_text, seen_entries)
                    
                    if new_rows:
                        all_prices.extend(new_rows)
                        print(f"         âœ… {position}: Extracted {len(new_rows)} rows.")
                    else:
                        print(f"         âš ï¸ {position}: No new data found.")

                except Exception as e:
                    print(f"         âŒ {position} Error: {e}")
                    continue

        # ë‚ ì§œìˆœ ì •ë ¬
        all_prices.sort(key=lambda x: x['departure_date'])
        
        return {
            "global_updates": {"is_vat_included": None, "cancellation_refund": None}, 
            "price_info": all_prices
        }

    def _parse_csv_to_json(self, csv_text, seen_entries):
        """CSV í…ìŠ¤íŠ¸ íŒŒì‹± ë° ì¤‘ë³µ ì œê±°"""
        rows = []
        lines = csv_text.split('\n')
        
        for line in lines:
            line = line.strip()
            if not line: continue
            # í—¤ë”ë‚˜ ì“°ë ˆê¸° ê°’ ê±´ë„ˆë›°ê¸°
            if "date" in line.lower() or "price" in line.lower(): continue
            
            parts = line.split(',')
            if len(parts) < 5: continue
            
            try:
                # 1. ë‚ ì§œ ì •ê·œí™”
                raw_date = parts[0].strip()
                clean_date = raw_date.replace('.', '-').replace('/', '-')
                date_parts = clean_date.split('-')
                
                # 23-11-01 -> 2023-11-01 ë³´ì •
                if len(date_parts) == 3:
                    if len(date_parts[0]) == 2: date_parts[0] = "20" + date_parts[0]
                    clean_date = f"{date_parts[0]}-{int(date_parts[1]):02d}-{int(date_parts[2]):02d}"
                else:
                    # ë‚ ì§œ í˜•ì‹ì´ íŒŒê´´ëœ ê²½ìš° ìŠ¤í‚µ
                    continue 

                # 2. ìˆ«ì ì¶”ì¶œ
                night = int(re.sub(r'\D', '', parts[1]))
                day = int(re.sub(r'\D', '', parts[2]))
                group = int(re.sub(r'\D', '', parts[3]))
                price = int(re.sub(r'\D', '', parts[4]))
                
                # 3. ì¤‘ë³µ ì²´í¬ (ë‚ ì§œ+ì¸ì›+ë°•ìˆ˜+ê°€ê²©ì´ ê°™ìœ¼ë©´ ë™ì¼ ë°ì´í„°ë¡œ ê°„ì£¼)
                unique_key = f"{clean_date}_{night}_{day}_{group}_{price}"
                
                if unique_key not in seen_entries:
                    seen_entries.add(unique_key)
                    rows.append({
                        "departure_date": clean_date,
                        "night_count": night,
                        "day_count": day,
                        "group_size": group,
                        "price_adult": price,
                        "status": "available"
                    })
            except Exception:
                continue
                
        return rows
            
    def _merge(self, prod, price):
        # ë°©ì–´ ì½”ë“œ: prodê°€ ì—¬ì „íˆ dictê°€ ì•„ë‹ˆë©´ ë¹ˆ dictë¡œ ì´ˆê¸°í™”
        if not isinstance(prod, dict): prod = {}
        if not isinstance(price, dict): price = {}

        # 1. ê°€ê²© ë¦¬ìŠ¤íŠ¸ ë³‘í•©
        prod["price_info"] = price.get("price_info", [])
        
        # 2. ê¸€ë¡œë²Œ ì •ì±… ì—…ë°ì´íŠ¸
        updates = price.get("global_updates", {})
        
        # basic_info í‚¤ê°€ ì—†ìœ¼ë©´ ìƒì„± (ë°©ì–´ ì½”ë“œ)
        if "basic_info" not in prod: prod["basic_info"] = {}
        if "policies" not in prod: prod["policies"] = {}

        if updates.get("is_vat_included") is not None:
            prod["basic_info"]["is_vat_included"] = updates["is_vat_included"]
            
        if updates.get("cancellation_refund"):
            prod["policies"]["cancellation_refund"] = updates["cancellation_refund"]
            
        return prod
# --- ì‹¤í–‰ ---
if __name__ == "__main__":
    # ì—‘ì…€ íŒŒì¼ì€ 'ë‹¤ë¥¸ ì´ë¦„ìœ¼ë¡œ ì €ì¥ > PDF'ë¡œ ë³€í™˜í•´ì„œ í…ŒìŠ¤íŠ¸í•˜ì„¸ìš”.
    PRODUCT_FILE = "../ERP í•„ìš”í•œ ë°ì´í„°/1. ëœë“œì‚¬í•œí…Œ ë°›ì€ ìƒí’ˆ_ì™„ë£Œ/ìƒí’ˆ/test.pdf"  # ìƒí’ˆì„¤ëª…ì„œ (pdf, docx ë“±)
    PRICE_FILE = "../ERP í•„ìš”í•œ ë°ì´í„°/1. ëœë“œì‚¬í•œí…Œ ë°›ì€ ìƒí’ˆ_ì™„ë£Œ/ê°€ê²©í‘œ/text.pdf"    # ì—‘ì…€ì„ PDFë¡œ ë³€í™˜í•œ íŒŒì¼

if os.path.exists(PRODUCT_FILE) and os.path.exists(PRICE_FILE):
    ai = TravelVisionAI()
    result = ai.process(PRODUCT_FILE, PRICE_FILE)
    
    print("\n" + "="*50)
    print("ğŸ¯ FINAL JSON RESULT")
    print("="*50)
    print(json.dumps(result, indent=2, ensure_ascii=False))
else:
    print("âŒ íŒŒì¼ ê²½ë¡œë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.")